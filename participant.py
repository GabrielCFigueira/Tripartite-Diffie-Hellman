#!/usr/bin/python3

from util import *
import math
import random
import hashlib
import itertools

class Participant:
    def __init__(self, name, curve, P, Q, S, order):
        # Name from set {'A','B','C'} of the participant
        self.name = name
        # Elliptic curve
        self.curve = curve
        # Order of generator points
        self.order = order
        # Point S used in Miller's Algorithm
        self.S = S
        # Dictionary used to store the public values from different participants
        self.publicKeys = {}
        # Generate a private key: integer k s.t. 1 < k < order - 1
        self.privateKey = random.randint(1,order)
        # Generate public values to broadcast to other 2 participants
        self.publicKeys['P_' + name] = doubleAndAdd(P, self.privateKey, curve)
        self.publicKeys['Q_' + name] = doubleAndAdd(Q, self.privateKey, curve)
        # Attribute that will store the shared key generated by the protocol
        self.sharedKeyHash = ""

    """ Generates the shared key of the Tripartite DH protocol """
    def generateSharedKey(self):
        # Pick the keys (one generated by point P of a participant
        # and another generated with point Q by the other participant)
        for key in self.publicKeys:
            if key.startswith("P") and (key != "P_" + self.name):
                P = key
        for key in self.publicKeys:
            if key.startswith("Q") and (key != "P_" + self.name) and (key[2] != P[2]):
                Q = key
        # Generate Weil Pairing (using Miller's Algorithm)
        weilpairing = WeilPairing(self.publicKeys.get(P), self.publicKeys.get(Q), self.S, self.order, self.curve)
        # Exponentiate Weil Pairing to private key and get shared key
        sharedKey = squareAndMultiply(weilpairing, self.privateKey)
        # Hash shared key so it can be used for symmetric crypto
        self.sharedKeyHash = hashlib.sha256(sharedKey.toString().encode()).hexdigest()


    """ Sends a tuple with the participant's public values """
    def sendPublicKeys(self):
        return (self.publicKeys['P_' + self.name], self.publicKeys['Q_' + self.name])

    """ Stores public values from another participant """
    def getPublicKeys(self, participant, keys):
        self.publicKeys['P_' + participant] = keys[0]
        self.publicKeys['Q_' + participant] = keys[1]
        if len(self.publicKeys) == 6:
            self.sharedKey = self.generateSharedKey()

    """ Ciphers message and returns it """
    def sendMessage(self, message):
        xorred = ''.join([chr(ord(x)^ord(y)) for x, y in zip(message, itertools.cycle(self.sharedKeyHash))])
        return xorred

    """ Deciphers message and prints it """
    def receiveMessage(self, message):
        print("Got this ciphered message: " + message)
        xorred = ''.join([chr(ord(x)^ord(y)) for x, y in zip(message, itertools.cycle(self.sharedKeyHash))])
        print("Deciphering I get: " + xorred)
